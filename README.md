
# Что это такое?

Сами решайте, мне просто было нечего делать...

А если серьезно, этот скрипт позволяет вам:

1. Использовать двухфакторную аутентификацию при входе пользователей через SSH
2. Получать предупреждение о каждой попытке входа через SSH
3. При правильной настройке, абсолютно игнорировать входы через нативные инструменты (например, через терминал сервера напрямую или через виртуализатор)
4. Запрет на использование команд, передаваемых сразу после утановки соединения (т.к. они выполняются до старта `.bashrc` пользователя)  
5. Задать свой MotD при входе на сервер, при этом:
- Поддерживается конвертация озображений из Base64
- Поддерживается цветность
- Поддерживается вывод анимированных изображений (Формата GIF)
- По-умолчанию для вывода изображений используются не обычные символы, а **глифы**, что позволяет сделать картинку существенно более четкой при выводе:

- - Примечание: Для реализации этого функционала используется утилита `Chafa`, подробнее ознакомиться с ней вы можете [здесь, на сайте разработчика](https://hpjansson.org/chafa/gallery/)

### Поддерживаемые оболочки: 
- `Bash`
- `SH` (не тестировалось)

---

# Как это настроить?

Чтобы настроить расширение у себя, выполните:

1. Установка зависимостей:

```bash
apt update && apt install chafa -y
```

2. Перенесита на сервер скрипт (в самом низу страницы) инициализации и расположите его в произвольной директории. Обратите внимание на парамтеры конфигурации, они описаны чуть ниже - заполните их
3. Отредайтируйте файл `~/.bashrc`, в самом конце файла укажите следующую конструкцию:

```bash
source ~/.start.sh
```

Где `~/.start.sh` - путь к скрипту, который вы копировали на сервер шагом ранее

4. Сделайте файл исполняемым командой: `chmod +x ~/.start.sh`
5. Выполните настройку PAM и SSHD, они описаны в главе "Какие дополнительные действия необходимо произвести?"
6. Скачайте релизную версию утилиты **Linux2FA** c  GitHub [по этой ссылке](https://github.com/Mineflat/Linux2FA). Расположите ее на сервере в произвольном месте и сделайте ее исполняемой: `chmod +x Linux2FA`
7. Отретайтируйте путь к утилите **Linux2FA**, он указан в функции `Init2FA`
8. Замените изображения в скрипте на свои, для этого:
- Перенесите файл изображения, поддерживаемый утилитой Chafa. Замените пути к ним при каждом вызове функции `PrintMOTd`. Если вы вовсе не хотите выводить изображения, закомментируйте все **содержимое** функции `PrintMOTd`

9. Попробуйте войти на сервер по SSH от имени того пользователя, чей файл `.bashrc` вы редактировали. 

10. *(опицонально)* После первоначальной настройки, если вы хотите использовать этот метод входа для всех пользователей (не меняя настройки), укажите в их файле `.bashrc` ссылку на исмполняемый файл `~/.start.sh`, прописав полный путь к нему на сервере (аналогично п.3)

---

# Как это работает?

Скрипт работает достаточно просто:

1. При входе пользователя (нативном или через SSH) выполняется скрипт `~/.bashrc` (если вы используете BASH)
2. В файле скрипта есть ссылка на скрипт-аутентификатор. При помощи команды `source` его содержимое вставляется в файл `~/.bashrc` и все команды в скрипте выполняются как, будто они написаны прямо в нем
3. Запускается сам скрипт-аутентификатор

Скрипт выполняет следующие действия:
1. Инициализация ряда переменных:
-  `TOKEN`: токен Телеграм-бота, от имени которого будут отправляться сообщения 
-  `CHAT_ID`: ID чата в Telegram, в который бот будет отправлять сообщения о попытке входа пользователя и подтверждения аутентификации через 2FA (если что-то из этого разрешено)  
-  `ENABLE_2FA`: разрешает или запрещает боту использовать двухфакторную аутентификацию через Телеграм. 
- - Принимаемые значения: `true` - разрешить, `false` - запретить
-  `ENABLE_LOGIN_WARN`: разрешает или запрещает отправку сообщения о попытке входа пользователя 
- - Принимаемые значения: `true` - разрешить, `false` - запретить

2. Инициализация ряда функций:
- `Init2FA` необходима для запуска двухфакторной аутентификации, если она разрешена на сервере. Фукнция вызывает стороннее приложение *Linux2FA*, код которого доступен на GitHub [по этой ссылке](https://github.com/Mineflat/Linux2FA)
- `PrintMOTd` необходима для конвертации и вывода изображений в терминал в текстовом формате. В этой функции настраиваются параметры вывода изображения: его цветность, используемые символы, размер изображения и др. Вывод любых картинок в терминал происходит именно через эту функцию, а пути к изображениям указываются при каждом вызове этого метода
- `SendTelegramAllert` используется для отправки сообщений о входе пользователя в систему. Текст сообщения в самой фукнции  

3. Проверка условий в порядке очереди:
```bash
if ( "тип-входа" == "нативный" ) {
    Показать_MOTd и запуск_интерпритатора
}

if ( разрешено_логирование_о_входе_пользователя ) {
    Логировать вход пользователя
    if ( Логирование_НЕ_удалось ) {
        Показать_MOTd и завершение_сессии_SSH
    }
}

if ( разрешено_использовать_2FA ) {
    Init2FA # запуск двухфакторной аутентификации
    if ( НЕ_удалось_подтвердить_личность_пользователя_через_2FA ) {
        Показать_MOTd и завершение_сессии_SSH
    }
    else Показать_MOTd и запуск_интерпритатора
}
```

---

# Какие дополнительные действия необходимо произвести?
## Запрет PTS

Позаботимся о безопасности подключения.

1. Отредактируйте файл `/etc/ssh/sshd_config` и добавьте (измените) следующий параметр:

```bash
PermitTTY yes
```

2. Откройте файл конфигурации PAM для SSH (`/etc/pam.d/sshd`) и внесите в него следующие изменения:

```bash
session required pam_tty_audit.so enable
```

3. После чего перезапустите SSHD командой:

```bash
systemctl restart sshd
```

### Что делает эта настройка?

Указывая в конфигурации SSHD `PermitTTY no` мы отключаем выделение терминала для SSH-подключений, что предотвращает создание PTS. 

В результате при подключении через SSH не будет выделяться терминал для ввода команд, и все интерактивные сессии (за исключением нативных, через хост-машину) будут невозможны.

### Зачем это нужно?

#### Про настройку `PermitTTY yes`

Это нужно для того, чтобы следующий блок кода в файле `start-SSHD.sh` обрабатывался правильно:

```bash
if [[ -z $SSH_TTY ]]; then
    PrintMOTd /srv/LinuxAuthorizer/img/welcome-home.jpg
    echo -E "Добро пожаловать домой"
    return 0
fi 
```

Здесь мы без проверок разрешаем нативный вход пользователя, если тот использует нативный метод входа (например, через терминал вирнтуализатора).

Это делается для того, чтобы не потерять доступ к хосту, ведь проверки, идещие далее, могут не пройти не по вине администратора, а, например, при недоступности серверов Телеграм (как в случае с проверкой 2FA).

SSH практически всегда использует PTS (pseudoterminal slave) для организации терминала пользователя при установлении сессии. Это обусловлено архитектурой работы SSH и его зависимостью от псевдотерминалов для управления вводом/выводом:
1. Эмуляция терминала:
- При подключении через SSH пользователь работает через эмулированный терминал, так как физическое устройство (например, клавиатура и экран) не подключено напрямую к удалённой системе.
- SSH выделяет для каждого пользователя отдельный псевдотерминал (PTS) через механизм ядра Linux.
2. Изоляция сессий:
- Каждый SSH-пользователь получает свой собственный PTS, что позволяет изолировать их ввод и вывод.
- Это важно для многопользовательских систем, где одновременно может быть несколько удалённых подключений.
3. Поддержка интерактивности:
- Псевдотерминалы предоставляют такие возможности, как работа с оболочкой (Bash, Zsh), выполнение интерактивных программ (например, текстовых редакторов, таких как vim), обработка сигналов (например, Ctrl+C) и другие функции, присущие терминалам.

Однако, есть и исключения:
1. Если при подключении через SSH используется флаг -T (disable pseudo-terminal allocation), SSH не создаёт PTS. 

Это может быть полезно для выполнения неинтерактивных задач, например:

```bash
ssh -T user@host "echo 'Hello, World!'"
```

В этом случае SSH передаёт команды напрямую в стандартный ввод/вывод удалённой оболочки, а не через псевдотерминал. 

2. Очевидно, если сервер SSH настроен так, чтобы не предоставлять псевдотерминалы

Например, в конфигурации `/etc/ssh/sshd_config` установлен параметр `PermitTTY no`, тогда PTS не будет создан.

Именно поэтому я рекомендую использовать опцию `PermitTTY yes`. Это гарантирует, что терминал будет выделяться для каждого подключения, и использование `-T` (которое отключает псевдотерминал) будет невозможным, т.е. **нативный вход через SSH (без аутентификации) будет под запретом** - он останется только для тех пользователей, которые используют истинный нативный вход (например, через терминал виртуализатора).

#### Про настройку `session required pam_tty_audit.so enable`

У вас может возникнуть закономерный вопрос: **А при чем тут вообще PAM?**

Ответ прост:

Чтобы гарантировать, что подключение через SSH требует использования PTS-терминала, а не TTY, при этом не ломая логику работы скрипта и не затрагивая пользователей, вошедших на хост используя нативные инструменты.

---

# Листинг скрипта

```bash
#!/bin/bash
###########################################
# Экспорт переменных окружения
###########################################
# Токен бота в Telegram
# Можно получить написал соответствующему боту:
# @BotFather
TOKEN="ВАШ-ТОКЕН-БОТА-В-ТЕЛЕГРАМ"
# ID чата в Telegram
# В него бот будет отправлять сообщения
# Обратите внимание, что бот должен присутствовать в этом чате: 
# Либо вы сами пишете своему боту, либо добавляете его в беседу 
# И даете ему уровень прав, достаточный на отправку сообщений,
# Либо пишите боту в личные сообщения самостоятельно
CHAT_ID="ВАШ-ID-ЧАТА-В-ТЕЛЕГРАМ"
# Разрешить боту использовать двухфакторную аутентификацию через Telegram  
ENABLE_2FA="true"
# Разрешить боту отправлять сообщения о входе пользователя на сервер
ENABLE_LOGIN_WARN="true"
# Многострочное сообщение в случае входа на сервер пользователя
# Может быть использован вывод других команды формата "$(command args)"
LOGIN_WARN_TEXT="Внимание! Пользователь **$(whoami)** пытается зайти на хост \`$(hostname -f) $(hostname -I)\`"
# Я хз зачем эта опция, ты просто получишь MOTD и все, вне зависимости от других проверок...
JIST_PRINT_MOTD="false"
###########################################
# Создание функций
###########################################
function SendTelegramAllert () {
    curl --silent -s -X POST "https://api.telegram.org/bot$TOKEN/sendMessage" \
            -d chat_id=$CHAT_ID \
            -d parse_mode="markdown" \
            -d text="$1" &> /dev/null
}
function Init2FA () {
    /srv/LinuxAuthorizer/apps/Linux2FA $TOKEN $CHAT_ID
}
function PrintMOTd () {
    # SEE MORE HERE:
    # https://man.archlinux.org/man/extra/chafa/chafa.1.en
    # chafa -f symbols --clear -c full --color-space din99d --symbols stipple $1
    chafa -f symbols -c full --color-space din99d --symbols inverted $1
    # chafa -f symbols --clear -c full --color-space din99d --symbols sextant $1
    # chafa -f symbols --clear -c full --color-space din99d --symbols solid $1
}
###########################################
# Основная логика скрипта
###########################################
tput clear
# Проверяем на всякий, что мы вошли не по SSH
# Если это так, то двухфакторка не должна действовать
# - иначе есть риск проебать доступ к серверу 
if [[ "$(echo $JIST_PRINT_MOTD)" == "true" ]]; then
    PrintMOTd /srv/LinuxAuthorizer/img/type4.jpg
    echo -e "Успешный вход пользователя \e[7;36;40m    $(whoami)    \e[0m на хост \e[1;36;40m$(hostname)\e[0m"
    return 0
fi

if [[ "$(who am i | grep 'pts')" == "" ]]; then
    PrintMOTd /srv/LinuxAuthorizer/img/welcome-home.jpg
    echo -E "Добро пожаловать домой"
    return 0
fi 

# if [ $# -ne 2 ] || [ "$1" != "-c" ] ; then
#     PrintMOTd /srv/LinuxAuthorizer/img/type6.jpg
#     echo -E "Interactive login not permitted"
#     exit 1
# fi


# Предупреждение о попытке входа на сервер
if [[ "$(echo $ENABLE_LOGIN_WARN)" == "true" ]]; then
    SendTelegramAllert $LOGIN_WARN_TEXT &> /dev/null
    if [[ "$(echo $?)" == "0" ]]; then
        if [[ "$(echo $ENABLE_2FA)" != "true" ]]; then
            tput clear
            PrintMOTd /srv/LinuxAuthorizer/img/type1.jpg
        fi
    else
        tput clear
        echo -e """
    Уважаемый \e[1;24m$(whoami)\e[0m, к сожалению, я не могу пустить тебя сюда, т.к. не могу оперативно доложить информацию о твоем присутствии своему владельцу...
    """
        PrintMOTd /srv/LinuxAuthorizer/img/type3.jpg
        exit 1
    fi
fi
# Инициация 2FA через Telegram
if [[ "$(echo $ENABLE_2FA)" == "true" ]]; then
    tput clear
    echo -e "Осталась всего одна проверка... Хозяин хоста знаем о чем идет речь"
    Init2FA &> /dev/null
    if [[ "$(echo $?)" == "0" ]]; then
        tput clear
        PrintMOTd /srv/LinuxAuthorizer/img/type5.jpg
    else
        tput clear
        echo -e """
    Уважаемый \e[1;24m$(whoami)\e[0m, к сожалению, я не могу пустить тебя сюда - ты не прошел одну из проверок.
    
    Примечание: 
        Тебя, пидорюгу, уже спалили. Еще несколько таких попыток и и я остановлю службу SSH - хуй ты сюда попадешь
        А твой адрес (\e[1;31m$(echo $SSH_CONNECTION | cut -d' ' -f1)\e[0m) отправлен администратору для принятия решения - че с тобой делать. 
        Твои попытки входа так же зарегистрированы и отправлены моему хозяину
    """
        PrintMOTd /srv/LinuxAuthorizer/img/type2.jpg
        exit 1
    fi
fi

echo -e "Успешный вход пользователя \e[7;36;40m    $(whoami)    \e[0m на хост \e[1;36;40m$(hostname)\e[0m"
```

---
